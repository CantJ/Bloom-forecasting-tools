# This script outlines the ParSens function that can be used to test the sensitivity of predicted spatio-temporal patterns in medusae density to the various demographic parameters supplied to the JellySim function
# This function follows a similar format to the JellySim function except that it implements an iterative test of the magnitude of change experienced in projected patterns
# And returns these values as its outputs rather than projected medusae densities.

# Primary Author: James Cant
# Contact: james.cant91@gmail.com
# -----------------------------------------------------------------------------

#----------------------------------------------------
# STEP 1: DEFINE PARAMETER SENSITIVITY FUNCTION
#----------------------------------------------------
# Like JellySim this function combines details outlining the location of initial ephyra release with information on projected abiotic conditions and localized water movements.
# However the function implements very small changes to supplied parameter values to determine how they impact projected density patterns.

ParSens <- function(pars, driftData, n_days, xmx, xmn, ymx, ymn, m, rel_location, rel_months, parallel,
                    # Its similarity to the JellySim functions means that ParSens is implemented using the same arguments. 
                    # It is expected that users would supply these arguments with the same parameters/details as provided to JellySim.
                    # There are three exceptions. Firstly, it is not possible to set multiple sampling iterations for the sensitivities assessments.
                    # Instead, the argument iter allows users to specify a number of repeated runs over which to compute variance in parameter sensitivity allowing for computation of stochastic variance. 
                    iter,
                    # Next parSens has two additional arguments that allow users to control the extent of their selected sensitivity tests.
                    s = 0.001, # scale of the deviation in parameter values to be imposed. Corresponds with the percentage of change to be imposed in parameter values. Defaults to 0.1%.
                    params = 'all'){ # a vector of the parameter names for which sensitivities should be computed. Defaults to 'all' which sensitivities computed for all available parameters.
  
  # The outputs generated by ParSens correspond with a bar plot visualising the relative sensitivities of all specified parameters and a data frame containing the raw sensitivity values.
  
  # Load package dependencies
  packages <- c('data.table','terra','sf', 'purrr', 'pbapply', 'gamlss.dist', 'abind', 'spsUtil', 'ggplot2')
  installed_packages <- packages %in% rownames(installed.packages())
  if (any(installed_packages == FALSE)) {
    install.packages(packages[!installed_packages], verbose = FALSE)
  }
  # Packages loading
  invisible(lapply(packages, library, character.only = TRUE))
  
  # define parallel processing details if requested
  if(parallel == TRUE) {
    # load additional required packages
    packages <- c('parallel', 'foreach', 'future', 'doFuture')
    installed_packages <- packages %in% rownames(installed.packages())
    if (any(installed_packages == FALSE)) {
      install.packages(packages[!installed_packages], verbose = FALSE)
    }
    invisible(lapply(packages, library, character.only = TRUE))
    
    # Open multicore interface
    nCores = detectCores() *0.5 # request 50% of the available cores so as not to overload the system
    plan(multisession, workers = nCores) 
  }
  
  # Just a little print out to manage user expectations
  cat('Depending on the number of parameters being tested this may take a while to complete. Hang in there!\n')
  
  # Repeat sensitivity computations to evaluate effect sizes across multiple density scenarios.
  # generate a sequence of random number seeds (for fixing stochasticity within iterations)
  seedSeq <- round(sample(0:1000000, iter, replace = F), 0)
  sensList <- list()
  for(es in 1:length(seedSeq)){
    # Implement baseline simulation with a call to the JellySim function.
    set.seed(es) # fix random number seed across repeated simulations to ensure consistent stochasticity across iterations.
    BaseSim <- quiet(JellySim(pars = pars, driftData = driftData, n_days = n_days, xmx = xmx, xmn = xmn, ymx = ymx, ymn = ymn,
                              m = m, zmax = 1, rel_location = rel_location, rel_months = rel_months, parallel = parallel))
    
    # Repeat simulation once for each specified parameter after applying a small adjustment to the selected parameter
    if(any(params == 'all')){
      # Define sensitivity storage
      sensVals <- numeric(length(pars))
      for(ii in 1:length(pars)){
        # impose percentage change to selected parameter
        newpars <- pars # duplicate parameter list
        newpars[ii] <- newpars[ii] + (newpars[ii] * s)
        # Re-run simulation
        set.seed(seedSeq[es]) # reset random number seed.
        sensSim <- quiet(JellySim(pars = newpars, driftData = driftData, n_days = n_days, xmx = xmx, xmn = xmn, ymx = ymx, ymn = ymn,
                                  m = m, zmax = 1, rel_location = rel_location, rel_months = rel_months, parallel = parallel))
        # Compute sensitivity
        sensVals[ii] <- sum(values(sensSim$mean) - values(BaseSim$mean))
      }
      # Store iteration output
      sensList[[es]] <- sensVals
    } else {
      # Define sensitivity storage
      sensVals <- numeric(length(params))
      for(ii in 1:length(params)){
        # impose percentage change to selected parameter
        newpars <- pars # duplicate parameter list
        newpars[params[ii]] <- newpars[params[ii]] + (newpars[params[ii]] * s) 
        # Re-run simulation
        set.seed(seedSeq[es]) # reset random number seed.
        sensSim <- quiet(JellySim(pars = newpars, driftData = driftData, n_days = n_days, xmx = xmx, xmn = xmn, ymx = ymx, ymn = ymn,
                                  m = m, zmax = 1, rel_location = rel_location, rel_months = rel_months, parallel = parallel))
        # Compute sensitivity
        sensVals[ii] <- sum(values(sensSim$mean) - values(BaseSim$mean))
      }
      # Store iteration output
      sensList[[es]] <- sensVals
    }
  }
  
  # Compute mean sensitivities and their variance across selected parameters. 
  if(any(params == 'all')) { sensVals <- data.frame(Name = names(pars), Sens = colMeans(do.call(rbind, sensList)), sd = sd(do.call(rbind, sensList)))
  } else { sensVals <- data.frame(Name = params, Sens = colMeans(do.call(rbind, sensList)), sd = sd(do.call(rbind, sensList))) }
  
  # Plot sensitivities
  # Generate plot
  sensPlot <- ggplot(data = sensVals, aes(x = Sens, y = Name)) +
    geom_col(width = 0.6, fill = '#2C2D7C') +
    geom_errorbar(aes(y = Name, xmin = Sens - sd, xmax = Sens + sd), data = sensVals) +
    geom_vline(aes(xintercept = 0), linetype = 'dashed', linewidth = 1.2, col = '#DC9257') +
    theme_classic() +
    theme(axis.line.x = element_line(linewidth = 1), axis.line.y = element_line(linewidth = 1)) +
    theme(axis.text.y = element_text(size = 10), axis.text.x = element_text(size = 15), axis.title = element_text(size = 20)) +
    theme(plot.background = element_rect(fill = 'white', color = 'white', linewidth = 0), 
          panel.background = element_rect(fill = 'white', color = 'white')) +
    xlab("\nProportional Sensitivity") +
    ylab("Parameter\n") +
    theme(plot.title = element_text(size = 20))
  
  # Return desired outputs
  return(list(plot = sensPlot, values = sensVals))
}

########################### END OF CODE -------------------------------------------
